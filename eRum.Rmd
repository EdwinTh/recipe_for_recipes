---
author: Edwin Thoen
title: "A recipe for recipes"
output: ioslides_presentation
---

## The `recipes` package

"Preprocessing Tools to Create Design Matrices"

Define the steps you'll take to go from raw data to the analysis set.

Store these steps into a procedure (a recipe), and apply it on new data.

You focus on the best steps to take, `recipes` does the bookkeeping.

On CRAN since

## The `recipes` package

A `recipe` is the specification of an intent, separate the planning from the doing.

<picture of a recipe>

## Creating a `recipe`

```{r, warning = FALSE}
train_set <- mtcars[1:20, c("am", "disp", "hp")]
test_set  <- mtcars[21:32, c("am", "disp", "hp")]
library(recipes)
library(dplyr)
rec <- recipe(train_set, am ~ .)
```

We have defined the roles here, `am` is the outcome, `disp` and `hp` are the predictors.

## Adding `steps` to the `recipe`

Once a recipe has created we can add steps to it.

```{r}
rec_with_steps <- rec %>% 
  step_center(all_predictors()) %>% 
  step_scale(all_predictors())
```

This is specifying the intent, we didn't do anything on the data yet.

## Preparing the recipe with `prep`

Here the work starts. By applying `prep` to the recipe, we are acquiring all the necesarry information on the training set. 

```{r}
rec_prepped <- rec_with_steps %>% 
  prep(train = train_set)
rec_prepped
```

We now have the statistics to apply the centering and scaling derived from the training set and stored in the recipe.

## Preparing the data with `bake`

```{r}
train_final <- bake(rec_prepped, train_set)
test_final  <- bake(rec_prepped, test_set)
```

The statistics to center and scale are learned on the `train_set` and applied to the `test_set`.

## Why am I talking about `recipes`?

Added the `check` framework together with Max.

A `check` does not change the data in any way, it tests assumptions and will break `bake` if these are not met.

```{r, error=TRUE}
rec <- recipe(train_set) %>% check_missing(everything()) %>% prep()
test_set[1, 1] <- NA
train_baked <- bake(rec, train_set)
test_baked  <- bake(rec, test_set)
```

## Building youw own steps and checks

Fully leverage package structure.

For your own preparations and to contribute to the package.

Challenge, delve a little deeper into the package inner workings.

## Aside: S3 objects

```{r}
eRum_generator <- function(name, country){
  x <- list(name = name, country = country)
  class(x) <- "eRum"
  x
}
eRum_generator("Edwin", "the Netherlands")

print.eRum <- function(x) {
  paste0(x$name, " from ", x$country, " is at eRum and thinks its awesome.") %>% 
    print()
}
eRum_generator("Edwin", "the Netherlands")
eRum_generator("Riccardo", "Italy")
```

## Aside: S3 objects

An S3 object is built by adding a `class` to a base object.

Functions that are specific for a class are called `methods`.

A `constructor` is a function that creates objects of a class in a uniform way.

## S3 classes in `recipes`

A recipe itself is of class `recipe`.

All the `steps` and `checks` available all have their own subclass. All with their own `prep` and `bake` functions. 

Recipe gathers all the objects of different subclasses.

When the methods `prep.recipe` and `bake.recipe` are called, they call the methods of the steps and checks.

## Create a custom `step` or `check`

A full step or check comprises:

- the function that is called to add to the recipe
- constructor to create new objects of the subclass
- `prep` method
- `bake` method
- `print` method
- `tidy` method

## A recipe for `recipes`

My preferred way to create a new `step` or `check`:

1) Write a function that does the baking action.
2) Recognize which arguments needs to be provided and which estimated by `prep`.
3) Write the constructor.
4) Write the function that adds the step or check.
5) Write the `prep` method.
6) Write the `bake` method.
7) Write the `print` method. 
8) Write the `tidy` method. 

## Resources

Within `recipes` you'll find a number of helper functions.

Clone the source code from github.com/topepo/recipes to access them.

On github.com/EdwinTh/recipe_for_recipes/ you will find a skeleton for new steps.

## Example 1: A signed log

In *Practical Data Science with R* (Zumel and Mount) the authors define the signed log as:

if |x| < 1: 0
else:       sign(x) * log(|x|)

## 1) the function for this is:
```{r}
signed_log <- function(x, base = exp(1)) {
  ifelse(abs(x) < 1, 
         0, 
         sign(x) * log(abs(x), base = base))
}
```

## 2) think about the arguments

We have one argument: `base`

Nothing has to be derived by `prep.signed_log`

## 3) The constructor

```{r}
step_signed_log_new <-
  function(terms   = NULL,
           role    = NA,
           skip    = FALSE,
           trained = FALSE,
           base    = NULL,
           columns = NULL) {
    step(
      subclass = "signed_log",
      terms    = terms,
      role     = role,
      skip     = skip,
      trained  = trained,
      base     = base,
      columns  = columns
    )
  }
```

## 4) The function to add it to the recipe

```{r}
step_signed_log <-
  function(recipe,
           ...,
           role    = NA,
           skip    = FALSE,
           trained = FALSE,
           base    = exp(1),
           columns = NULL) {
    add_step(
      recipe,
      step_signed_log_new(
        terms   = ellipse_check(...),
        role    = role,
        skip    = skip,
        trained = trained,
        base    = base,
        columns = columns
      )
    )
  }
```

## 5) the `prep` method

```{r}
prep.step_signed_log <- function(x,
                                 training,
                                 info = NULL, 
                                  ...) {
  col_names <- terms_select(x$terms, info = info)
  step_signed_log_new(
    terms   = x$terms,
    role    = x$role,
    skip    = x$skip,
    trained = TRUE,
    base    = x$base,
    columns = col_names
  )
}
```

## 6) the `bake` method

```{r}

bake.step_signed_log <- function(object,
                                 newdata,
                                 ...) {
  col_names <- object$columns
  for (i in seq_along(col_names)) {
    col <- newdata[[ col_names[i] ]]
    newdata[, col_names[i]] <-
      ifelse(abs(col) < 1, 
             0, 
             sign(col) * log(abs(col), base = object$base))
  }
  as_tibble(newdata)
}
```

## 7) the `print` method 

```{r}
print.step_signed_log <-
  function(x, width = max(20, options()$width - 30), ...) {

    cat("Taking the signed log for ", sep = "")
    printer(x$columns, x$terms, x$trained, width = width)

    invisible(x)
}
```

## 8) the `tidy` method

```{r}
tidy.step_signed_log <- function(x, ...) {
  if (is_trained(x)) {
    res <- tibble(terms = x$columns)
  } else {
    res <- tibble(terms = sel2char(x$terms))
  }
  res
}
```

```{r}
df <- data_frame(x = -2:2)
recipe(df) %>% step_signed_log(x) %>% prep() %>% bake(df)
```



## Example 2: A range check

Assure that the range of a numeric variable in a new set is approximately equal to the range of the original.

Throw informative error when on one or both ends the new variable exceeds the original range plus some slack.

## 1) the function for this is:

```{r}
range_check_func <- function(x,
                             lower,
                             upper,
                             slack_prop = 0.05,
                             colname = "x") {
  min_x <- min(x)
  max_x <- max(x)
  slack <- (upper - lower) * slack_prop
  if (min_x < (lower - slack) & max_x > (upper + slack)) {
    stop("min ", colname, " is ", min_x, ", lower bound is ", lower - slack, "\n",
         "max x is ", max_x, ", upper bound is ", upper + slack)
  } else if (min_x < (lower - slack)) {
    stop("min ", colname, " is ", min_x, ", lower bound is ", lower - slack)
  } else if (max_x > (upper + slack)) {
    stop("max ", colname, " is ", max_x, ", upper bound is ", upper + slack)
  }
}
```

## 2) thinking about the arguments

`slack_prop` is an argument provided by the user.

`lower` and `upper` should be calculated in the `prep` step.

## 3) the constructor

```{r}
check_range_new <-
  function(terms = NULL,
           role  = NA,
           trained = FALSE,
           lower   = NULL,
           upper   = NULL,
           slack_prop = NULL) {
    check(subclass = "range",
          terms    = terms,
          role     = role,
          trained  = trained,
          lower    = lower,
          upper    = upper,
          slack_prop = slack_prop)
  }
```

## 4) the function itself

```{r}
check_range <-
  function(recipe,
           ...,
           role = NA,
           trained = FALSE,
           lower   = NULL,
           upper   = NULL,
           slack_prop = 0.05) {
    add_check(
      recipe,
      check_range_new(
        terms   = ellipse_check(...),
        role    = role,
        trained = trained,
        lower   = lower,
        upper   = upper,
        slack_prop = slack_prop
      )
    )
  }
```

## 5) the `prep` method

```{r}
prep.check_range <-
  function(x,
           training,
           info = NULL,
           ...) {
    col_names <- terms_select(x$terms, info = info)

    lower_vals <- vapply(training[ ,col_names], min, c(min = 1), na.rm = TRUE)
    upper_vals <- vapply(training[ ,col_names], max, c(max = 1), na.rm = TRUE)

    check_range_new(
      x$terms,
      role = x$role,
      trained = TRUE,
      lower   = lower_vals,
      upper   = upper_vals,
      slack_prop = x$slack_prop
    )
  }
```

## 6) the `bake` method

```{r}
bake.check_range <- function(object,
                             newdata,
                             ...) {
  col_names <- names(object$lower)
  for (i in seq_along(col_names)) {
    colname <- col_names[i]
    range_check_func(newdata[[ colname ]],
                     object$lower[colname],
                     object$upper[colname],
                     object$slack_prop,
                     colname)
  }
  as_tibble(newdata)
}
```

## 7) the `print` method

```{r}
print.check_range <-
  function(x, width = max(20, options()$width - 30), ...) {
    cat("Checking range of ", sep = "")
    printer(names(x$lower), x$terms, x$trained, width = width)
    invisible(x)
  }
```

## 8) the `tidy` method

```{r}
tidy.check_range <- function(x, ...) {
  if (is_trained(x)) {
    res <- tibble(terms = x$columns)
  } else {
    res <- tibble(terms = sel2char(x$terms))
  }
  res
}
```

